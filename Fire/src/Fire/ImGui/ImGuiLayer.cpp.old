#include "frpch.h"
#include "ImGuiLayer.h"

#include "imgui.h"
//#include "backends/imgui_impl_glfw.h"
//#include "backends/imgui_impl_opengl3.h"
#include "GLFW/glfw3.h"
#include "glad/glad.h"

//#include "Platform/OpenGL/ImGuiOpenGLRenderer.h"
//#include "Platform/OpenGL/imgui_impl_opengl3.h"

#include "Fire/Application.h"

namespace Fire {

	ImGuiLayer::ImGuiLayer()
		: Layer("ImGuiLayer")
	{
	}

	ImGuiLayer::~ImGuiLayer()
	{
	}

	void ImGuiLayer::OnAttach()
	{
		ImGui::CreateContext();
		ImGuiIO& io = ImGui::GetIO();
		ImGui::StyleColorsDark();

		///
		Application& app = Application::Get();								// The tutorial code does not do this but mine fails segmentation without it;
		GLFWwindow* window = (GLFWwindow*) app.GetWindow().GetNativeWindow();		// This version handles callbacks that the tutorial code doesn't. This is likely to do with the way ImGui has been added/called.
		ImGui_ImplGlfw_InitForOpenGL(window, true);							// 
		///

	    ImGui_ImplOpenGL3_Init("#version 150");
	}

	void ImGuiLayer::OnDetach()
	{
		
	}

	void ImGuiLayer::OnUpdate()
	{
		//ImGuiIO& io = ImGui::GetIO();
		//Application& app = Application::Get();
		//io.DisplaySize = ImVec2(app.GetWindow().GetWidth(),app.GetWindow().GetHeight());

		//float time = (float)glfwGetTime();
		//io.DeltaTime = m_Time > 0.0 ? (time-m_Time) : (1.0f/60.0f);
		//m_Time = time;

		ImGui_ImplOpenGL3_NewFrame();
        ImGui_ImplGlfw_NewFrame(); //
        ImGui::NewFrame();

		/*bool show_another_window = true;						//// This code from the ImGui example codebase
		ImGui::Begin("Another Window", &show_another_window);   // Pass a pointer to our bool variable (the window will have a closing button that will clear the bool when clicked)
        ImGui::Text("Hello from another window!");
        if (ImGui::Button("Close Me"))
            show_another_window = false;
        ImGui::End();*/

        static bool show = true;
		ImGui::ShowDemoWindow(&show);

		ImGui::Render();
        ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
	}

	///////////////////////////////////////
	// Event handlers
	///////////////////////////////////////

	// Setup event handlers
	void ImGuiLayer::OnEvent(Event& event)
	{
		EventDispatcher dispatcher(event);

		//  !!! Events already seem to be handled by ImGui, these add/clash with those events
		//  !!! Incompatible keydown methods fail ImGui assert

		/*dispatcher.Dispatch<MouseButtonPressedEvent>(FR_BIND_EVENTS_FN(ImGuiLayer::OnMouseButtonPressedEvent));		// Dispatch function checks against template type <T> and runs if it matches
		dispatcher.Dispatch<MouseButtonReleasedEvent>(FR_BIND_EVENTS_FN(ImGuiLayer::OnMouseButtonReleasedEvent));
		dispatcher.Dispatch<MouseMovedEvent>(FR_BIND_EVENTS_FN(ImGuiLayer::OnMouseMovedEvent));
		dispatcher.Dispatch<MouseScrolledEvent>(FR_BIND_EVENTS_FN(ImGuiLayer::OnMouseScrolledEvent));
		dispatcher.Dispatch<KeyPressedEvent>(FR_BIND_EVENTS_FN(ImGuiLayer::OnKeyPressedEvent));
		dispatcher.Dispatch<KeyReleasedEvent>(FR_BIND_EVENTS_FN(ImGuiLayer::OnKeyReleasedEvent));
		dispatcher.Dispatch<KeyTypedEvent>(FR_BIND_EVENTS_FN(ImGuiLayer::OnKeyTypedEvent));
		dispatcher.Dispatch<WindowResizeEvent>(FR_BIND_EVENTS_FN(ImGuiLayer::OnWindowResizeEvent));*/
	}

	bool ImGuiLayer::OnMouseButtonPressedEvent(MouseButtonPressedEvent& e)
	{
		ImGuiIO& io = ImGui::GetIO();
		io.MouseDown[e.GetMouseButton()] = true;

		return false;		// Mouse click propagates to other layers for now...
	}

	bool ImGuiLayer::OnMouseButtonReleasedEvent(MouseButtonReleasedEvent& e)
	{
		ImGuiIO& io = ImGui::GetIO();
		io.MouseDown[e.GetMouseButton()] = false;

		return false;
	}
	
	bool ImGuiLayer::OnMouseMovedEvent(MouseMovedEvent& e)
	{
		ImGuiIO& io = ImGui::GetIO();
		io.MousePos = ImVec2(e.GetX(), e.GetY());

		return false;
	}
	
	bool ImGuiLayer::OnMouseScrolledEvent(MouseScrolledEvent& e)
	{
		ImGuiIO& io = ImGui::GetIO();
		io.MouseWheelH += e.GetXOffset();
		io.MouseWheel  += e.GetYOffset();

		return false;
	}
	
	bool ImGuiLayer::OnKeyPressedEvent(KeyPressedEvent& e)
	{
		ImGuiIO& io = ImGui::GetIO();
		io.KeysDown[e.GetKeyCode()] = true;

		// Key modifiers
		io.KeyCtrl = io.KeysDown[GLFW_KEY_LEFT_CONTROL] || io.KeysDown[GLFW_KEY_RIGHT_CONTROL];
		io.KeyShift = io.KeysDown[GLFW_KEY_LEFT_SHIFT] || io.KeysDown[GLFW_KEY_RIGHT_SHIFT];
		io.KeyAlt = io.KeysDown[GLFW_KEY_LEFT_ALT] || io.KeysDown[GLFW_KEY_RIGHT_ALT];
		io.KeySuper = io.KeysDown[GLFW_KEY_LEFT_SUPER] || io.KeysDown[GLFW_KEY_RIGHT_SUPER];
		return false;
	}
	
	bool ImGuiLayer::OnKeyReleasedEvent(KeyReleasedEvent& e)
	{
		ImGuiIO& io = ImGui::GetIO();
		io.KeysDown[e.GetKeyCode()] = false;
		
		return false;
	}
	
	bool ImGuiLayer::OnKeyTypedEvent(KeyTypedEvent& e)
	{
		ImGuiIO& io = ImGui::GetIO();
		int keycode = e.GetKeyCode();
		if (keycode > 0 && keycode < 0x10000)
			io.AddInputCharacter((unsigned short)keycode);

		return false;
	}

	bool ImGuiLayer::OnWindowResizeEvent(WindowResizeEvent& e)
	{
		ImGuiIO& io = ImGui::GetIO();
		io.DisplaySize = ImVec2(e.GetWidth(),e.GetHeight());
		io.DisplayFramebufferScale = ImVec2(1.0f,1.0f);
		glViewport(0,0,e.GetWidth(),e.GetHeight());
		return false;
	}
	

}